<!DOCTYPE html>
<style>
  
svg {
 font: 16px"Avenir";

}
  
  div.tooltip {	
    position: absolute;			
    text-align: center;			
    width: 60px;					
    height: 45px;					
    padding: 2px;				
    font: 12px sans-serif;		
    background: lightsteelblue;	
    border: 0px;		
    border-radius: 8px;			
    pointer-events: none;			
  }
  
  .area {
  fill: steelblue;
  clip-path: url(#clip);
}


</style>
<svg width="700" height="700" font-family="sans-serif" font-size="10" text-anchor="middle"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>


  
var svg = d3.select("svg"),
	margin = {top: 20, right: 20, bottom: 110, left: 40},
    margin2 = {top: 600, right: 20, bottom: 30, left: 40},
    width = +svg.attr("width") - margin.left - margin.right,
    height = +svg.attr("height") - margin.top - margin.bottom,
    height2 = +svg.attr("height") - margin2.top - margin2.bottom;
	/*
    width = +svg.attr("width"),
    height = +svg.attr("height"),
	margin = {top: 20, right: 20, bottom: 110, left: 40},
	margin2 = {top: 700, right: 20, bottom: 30, left: 40},
	height2 = +svg.attr("height") - margin2.top - margin2.bottom;
	*/
	
var x = d3.scaleLinear().range([0, width]),
    y2 = d3.scaleLinear().range([height2, 0]);
	
var xAxis = d3.axisBottom(x),
	yAxis2 = d3.axisLeft(y2).ticks(3);
	
var brush = d3.brushX()
    .extent([[0, 0], [width, height2]])
    .on("brush end", brushed);
	
var area2 = d3.area()
    .curve(d3.curveLinear)		// maybe use d3.curveStep instead?
    .x(function(d) { return x(d.Call_Type); })
    .y0(height2)
    .y1(function(d) { return y2(d.value); });
	
var focus = svg.append("g")
    .attr("class", "focus")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	
// bottom chart
var context = svg.append("g")
    .attr("class", "context")
    .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

/*
// Define the div for the tooltip
var div = d3.select("body").append("div")	
    .attr("class", "tooltip")				
    .style("opacity", 0);
*/

 /*
  svg.append("text")
    .attr("x", 100)   
    .attr("y", 20 )
    .attr("dy", "3.5em" )
    .attr("text-anchor", "start")  
    .style("font-size", "28px")  
  	.style("font-weight", "bold")
    .text("SFFD Call Incidents in December 2016 ")
*/

var pack = d3.pack()
    .size([width-150, height])
    .padding(1.5);

d3.csv("bubble.csv", 
	function(d) {
		d.value = +d["Count"];
		d.Call_Type = d["Year"]

		return d;
	}, 
	function(error, data) {
		if (error) throw error;
		
		x.domain(d3.extent(data, function(d) { return d.Call_Type; }));
		y2.domain([0, d3.max(data, function(d) { return d.value; })]);
	
		var color = d3.scaleOrdinal()
					  .domain(data.map(function(d){ return d.Call_Type; }))
					  .range(['#fbb4ae','#b3cde3','#ccebc5','#decbe4','#fed9a6', '#ffe9a8','#b9bfe3','#fddaec','#cccccc']);
  
		var root = d3.hierarchy({children: data})
				     .sum(function(d) { return d.value; })

		var node = svg.selectAll(".node")
					  .data(pack(root).leaves())
					  .enter().append("g")
					  .attr("class", "node")
					  .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
 
  
		node.append("circle")
				.attr("id", function(d) { return d.id; })
				.attr("r", function(d) { return d.r; })
				.style("fill", function(d) { return color(d.data.Call_Type); })
				/*
				.on("mouseover", function(d) {		
					div.transition()		
					.duration(200)		
					.style("opacity", .9);	
					var duration = 300;
					data.forEach(function(d, i) {
						console.log(d.value);
						node.transition().duration(duration).delay(i * duration)
							.attr("r", d.value);
					});
					div.html(d.data.Call_Type + ": <br>"+d.data.value  )	
					  .style("left", (d3.event.pageX) + "px")		
					  .style("top", (d3.event.pageY - 28) + "px");	
				})					
				.on("mouseout", function(d) {		
					div.transition()		
					.duration(500)		
					.style("opacity", 0);	
				})
				*/
				;

  
  
		node.append("text")
				.text(function(d) {
					if (d.data.value > 0 || d.data.Call_Type == "Other" || d.data.Call_Type == "Fire"){
						return d.data.Call_Type;
					}
					return "";
				});
				
		focus.append("g")
             .attr("class", "axis axis--y")
	         .attr("transform", "translate(0," + (height + 10) + ")")
             .call(yAxis2);
		
		// context is the bottom chart
		context.append("path")
			  .datum(data)
			  .attr("class", "area")
			  .attr("d", area2);

		context.append("g")
			  .attr("class", "axis axis--x")
			  .attr("transform", "translate(0," + height2 + ")")
			  .call(xAxis);

		context.append("g")
			  .attr("class", "brush")
			  .call(brush)
			  .call(brush.move, x.range());
		
  
/*
  var legend = svg.selectAll(".legend")
  .data(data).enter()
  .append("g")
  .attr("class","legend")
  .attr("transform", "translate(" + 780 + "," + 120+ ")");
     
 
   legend.append("rect")
     .attr("x", 0) 
     .attr("y", function(d, i) { return 20 * i; })
     .attr("width", 15)
     .attr("height", 15)
		.style("fill", function(d) { return color(d.Call_Type)});
   

    legend.append("text")
     .attr("x", 25) 
    	.attr("text-anchor", "start")
     .attr("dy", "1em") 
     .attr("y", function(d, i) { return 20 * i; })
     .text(function(d) {return d.Call_Type;})
    .attr("font-size", "12px"); 
  
      
    legend.append("text")
     .attr("x",31) 
     .attr("dy", "-.2em")
     .attr("y",-10)
     .text("Call Type")
  	.attr("font-size", "17px"); 
*/
  
  
});

function brushed() {
	// TODO: fix this
	//return;
	var s = d3.event.selection || x2.range();
	//svg.selectAll(".node").remove();
	/*
	if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
	var s = d3.event.selection || x2.range();
	x.domain(s.map(x2.invert, x2));
	focus.select(".area").attr("d", area);
	focus.select(".axis--x").call(xAxis);
	svg.select(".zoom").call(zoom.transform, d3.zoomIdentity
		.scale(width / (s[1] - s[0]))
		.translate(-s[0], 0));
	*/
}

</script>
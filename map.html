<!DOCTYPE html>
<meta charset="utf-8">
<style>

.background {
  fill: none;
  pointer-events: all; 
}

.feature {
  fill: #ccc;
  cursor: pointer;
}

.feature.active {
  fill: orange;
}

.country {
  fill: #ccc;
  cursor: pointer;
}

.mesh {
  fill: none;
  stroke: #fff;
  stroke-linecap: round;
  stroke-linejoin: round;
}

.centroid {
  /* fill: #ab1bab; */
  stroke: #000;
  stroke-width: 0.1;
  cursor: pointer;
}

.contCentroid {
  stroke: #000;
  stroke-width: 0.1;
  cursor: pointer;
}

.hidden {
  display: none;
}

</style>

<body>
</body>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/topojson.v2.min.js"></script>
<script src="https://d3js.org/d3-queue.v3.min.js"></script>
<script>

var width = 960,
    height = 700,
    padding = 1.5,
    paddingFactor = 1.5,
    clusterPadding = 6,
    maxRadius = 12, // this should actually vary with the current node options
    active = d3.select(null);

var projection = d3.geoMercator()
    .scale(150)
    .translate([width / 2, height / 2]);
  
var zoom = d3.zoom().on("zoom", zoomed);
var path = d3.geoPath().projection(projection);

var countryMode = false;  // delete?

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
    .on("click", stopped, true);

svg.append("rect")
    .attr("class", "background")
    .attr("width", width)
    .attr("height", height)
    .on("click", reset);

var base_g = svg.append("g");

var continentClusterCodes = {
	"Africa": 1,
	"Asia": 2,
	"Europe": 3,
	"North America": 4,
	"South America": 5,
	"Oceania": 6,
	"Antarctica": 7
}

var centroidItems = [];
var continentCentroids = {};
  
svg.call(zoom); // delete this line to disable free zooming

d3.queue()
  	.defer(d3.json, "world-continents.json")
  	.defer(d3.json, "world-countries.json")
  	.defer(d3.csv, "world_country_names.csv")
  	.defer(d3.csv, "wrangle.csv")
  	.await(setup);

function setup(error, worldContinents, worldCountries, names, exchange) {
	if (error) throw error;

	var continentsData = topojson.feature(worldContinents, worldContinents.objects.continent).features;
	var countriesData = topojson.feature(worldCountries, worldCountries.objects.countries).features;

	// set up continents
	var continent_gs = base_g.append("g")
    .attr("class", "feature continent")
    .selectAll(".feature")
    .data(continentsData)
    .enter()
    .append("path")
    .attr("name", function(d) {return d.properties.continent;})
    // .attr("id", function(d) { return d.id;})
    .on('click', continentClicked)
    // .on("mousemove", showTooltip)
    // .on("mouseout",  function(d,i) {
    //    tooltip.classed("hidden", true);
    // })
    .attr("d", path);

  for (var c of continentsData) {
    var centroid = path.centroid(c);
		continentCentroids[c.properties.continent] = {
			  x: path.centroid(c)[0],
			  y: path.centroid(c)[1],
			  radius: 0
		};
	}
	console.log(continentCentroids);

  /* for debugging continent centroid locations */
  var ccs = [];
  for (cname in continentCentroids) {
    ccs.push(continentCentroids[cname]);
  }

  var contCentroidElements = base_g.selectAll(".contCentroid")
    .data(ccs)
    .enter()
    .append("g");

  var contCentroids = contCentroidElements.append("circle")
    .attr("class", "contCentroid")
    .attr("fill", function(d) { return "#ff0000"; })
    .attr("r", function(d) { return 10; })
    .attr("cx", function(d) { return d.x; })
    .attr("cy", function(d) { return d.y; });
  /* end debug */

  // filter exchange here to get countryExchangeData
  var countryExchangeData = {} // incorporate three-letter code

  // set up countries
  countriesData.filter(function(d) {
  	return names.some(function(n) {
  		if (parseInt(d.id) == parseInt(n.id)) {
  			d.name = n.name;
  			d.nameCode = n.alpha_3;
  			if (n.region != "Americas") {
  				d.region = n.region;
  			} else if (n.subregion == "South America") { 
  				d.region = n.subregion; 
  			} else {
  				d.region = "North America";
  			}
        d.radius = Math.floor(Math.random()*10); // irl to be determined by exchange data
        /* debug for identifying separate clusters */
        switch(continentClusterCodes[d.region]) {
          case 1:
            d.color = "#ffff00";
            break;
          case 2:
            d.color = "#00ffff";
            break;
          case 3:
            d.color = "#00ff00";
            break;
          case 4:
            d.color = "#0000ff";
            break;
          case 5:
            d.color = "#007700";
            break;
          case 6:
            d.color = "#ff00ff";
            break;
          case 7:
            d.color = "#770000";
            break;
          default:
            d.color = "#000";
        }
        /* end debug */
  		}
  	});

	  	// for when countryExchangeData is implemented
	  	/* countryExchangeData.some(function(e) {
	  		if (d.nameCode = e.nameCode) {
		  		d.radius = 5;
		  		d.color = #ab1bab;
		  	}
	  	}); */
	});


  var continents = base_g.selectAll(".continent");
  var countries = base_g.selectAll(".country");  // remove

	/* base_g.selectAll("path")
      .data(continents)
      .enter()
      .append("path")
      .attr("d", path)
      .attr("class", "feature continent")
      .on("click", continentClicked);

  	base_g.append("path")
      .datum(topojson.mesh(worldContinents, worldContinents.objects.continent, function(a, b) { return a !== b; }))
      .attr("class", "mesh")
      .attr("d", path); */

    // console.log(continents[0]);
    // console.log(path.bounds(base_g.selectAll("path")[0]));

    /* var countries = topojson.feature(worldCountries, worldCountries.objects.countries).features;

    console.log(countries[0]);

	countriesData.filter(function(d) {
	  	return names.some(function(n) {
	  		if (d.id == n.id) return d.name = n.name;
	  	})
	});

	  base_g.selectAll("path")
	      .data(countries)
	      .enter()
	      .append("path")
	      .attr("d", path)
	      .attr("class", "country")
	      .on("click", countryClicked);

	  base_g.append("path")
	      .datum(topojson.mesh(worldCountries, worldCountries.objects.countries, function(a, b) { return a !== b; }))
	      .attr("class", "mesh")
	      .attr("d", path); */

   centroidItems = countriesData.map(function(feature) {
  		var centroidItem = {
  			x: path.centroid(feature)[0],
  			y: path.centroid(feature)[1],
  			radius: feature.radius,
  			name: feature.name,
  			color: feature.color,
  			cluster: continentClusterCodes[feature.region],
  			region: feature.region
  		};
  		return centroidItem;
		});
  // console.log(centroidItems[0]);


  var simulation = d3.forceSimulation(centroidItems)
	  .velocityDecay(0.1)
    .force('x', d3.forceX()
      .strength(0.007)
      .x(function(d) {
        if(d.region) {
          var cluster = continentCentroids[d.region];
          return cluster.x;
        } else {
          return d.x;
        }
      })
    )
    .force('y', d3.forceY()
      .strength(0.007)
      .y(function(d) {
        if(d.region) {
          var cluster = continentCentroids[d.region];
          return cluster.y;
        } else {
          return d.y;
        }
      })
    )
    .force("collide", collide)
    // .force("cluster", cluster)
    .on("tick", tick);

  var centroidElements = base_g.selectAll(".centroid")
  	.data(centroidItems)
  	.enter()
  	.append("g");

  var centroids = centroidElements.append("circle")
  	.attr("class", "centroid")
  	.attr("fill", function(d) { return d.color; })
  	.attr("r", function(d) { return d.radius; })
  	.attr("cx", function(d) { return d.x; })
    .attr("cy", function(d) { return d.y; })
    .on("click", countryClicked);

  centroidElements.append("text")
  	.text(function(d) { return d.name; })
  	.attr("x", function(d) { return d.x; })
    .attr("y", function(d) { return d.y; })
    .attr("font-size", "10px")
    .attr("text-anchor", "middle");

  // console.log(centroidElements);

}

// When a continent is clicked, zoom in and show the country level map
function continentClicked(d) {
  /* if (active.node() === this) return reset(); */
  active.classed("active", false);
  active = d3.select(this).classed("active", true);

  // console.log(d);

  var bounds = path.bounds(d),
      dx = bounds[1][0] - bounds[0][0],
      dy = bounds[1][1] - bounds[0][1],
      x = (bounds[0][0] + bounds[1][0]) / 2,
      y = (bounds[0][1] + bounds[1][1]) / 2,
      scale = Math.max(1, Math.min(8, 0.9 / Math.max(dx / width, dy / height))),
      translate = [width / 2 - scale * x, height / 2 - scale * y];

  // console.log(path.bounds(d));
  // console.log(bounds);

  svg.transition()
      .duration(750)
      .call( zoom.transform, d3.zoomIdentity.translate(translate[0],translate[1]).scale(scale) );

  // base_g.selectAll(".country")

  /* d3.queue()
  	.defer(d3.json, "https://unpkg.com/world-atlas@1/world/50m.json")
  	.defer(d3.csv, "final_data/world_country_names.csv")
  	.await(update);

  function update(error, world, names) {
	  if (error) throw error;

	  var countries = topojson.feature(world, world.objects.countries).features; 

	  var namedCountries = countries.filter(function(d) {
	  	return names.some(function(n) {
	  		if (d.id == n.id) return d.name = n.name;
	  	})
	  });

	  /* base_g.selectAll("path")
	      .data(countries)
	      .enter()
	      .append("path")
	      .attr("d", path)
	      .attr("class", "country")
	      .on("click", countryClicked);

	  base_g.append("path")
	      .datum(topojson.mesh(world, world.objects.countries, function(a, b) { return a !== b; }))
	      .attr("class", "mesh")
	      .attr("d", path);

	  var centroidItems = countries.map(function(feature) {
    		var centroidItem = path.centroid(feature);
    		centroidItem.push(feature.name);
    		return centroidItem;
  		});
	  console.log(centroidItems[0]);

	  var centroidElements = base_g.selectAll(".centroid")
	  	.data(centroidItems)
	  	.enter()
	  	.append("g");

	  centroidElements.append("circle")
	  	.attr("class", "centroid")
	  	.attr("r", 5)
	  	.attr("cx", function(d) { return d[0]; })
        .attr("cy", function(d) { return d[1]; })
        .on("click", countryClicked);

      centroidElements.append("text")
      	.text(function(d) { return d[2]; })
      	.attr("x", function(d) { return d[0]; })
        .attr("y", function(d) { return d[1]; })
        .attr("font-size", "10px")
        .attr("text-anchor", "middle");

	  countryMode = true;
	} */
}

function countryClicked(d) {
	/* if (active.node() === this) return reset();
  	active.classed("active", false);
  	active = d3.select(this).classed("active", true); */
	console.log("country clicked");
	console.log(d);
}

function reset() {
  active.classed("active", false);
  active = d3.select(null);

  svg.transition()
      .duration(750)
      .call( zoom.transform, d3.zoomIdentity ); 

  if (countryMode) {
  	// base_g.selectAll(".country").exit().remove();
  	// base_g.selectAll("path").exit().remove();
  	countryMode = false;
  	console.log(base_g.selectAll(".country"));
  	console.log(base_g.selectAll("path"));
  }
}

function zoomed() {
  base_g.style("stroke-width", 1.5 / d3.event.transform.k + "px");
  base_g.attr("transform", d3.event.transform); 

  var continents = base_g.selectAll(".continent");
  var countries = base_g.selectAll(".country");

  var s = d3.event.scale;

  if(s > 1.5) {
		countries.attr("class", "feature country");
		continents.attr("class", "feature continent hidden");
  		/*
        states
          .classed('hidden', false);
        usa
          .classed('hidden', true);
        canada
          .classed('hidden', true);
        */
  } else {
    countries.attr("class", "feature country hidden");
		continents.attr("class", "feature continent");
      /*
      states
        .classed('hidden', true);
      usa
        .classed('hidden', false);
      canada
        .classed('hidden', false);
     */
  }
}

// If the drag behavior prevents the default click,
// also stop propagation so we don’t click-to-zoom.
function stopped() {
  if (d3.event.defaultPrevented) d3.event.stopPropagation();
}

function tick(e) {
	// console.log(e);
 	base_g.selectAll(".centroid")
      // .each(cluster(10 * e.alpha * e.alpha))
      // .each(collide(.5))
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
}

// Move d to be adjacent to the cluster node.
function cluster(alpha) {
  // return function(d) {
    // if (cluster === d) return;
  // console.log(centroidItems);
  // console.log("alpha: " + alpha);
  centroidItems.forEach(function(d) {
  	// console.log(d);
  	// console.log(continentCentroids[d.region]);
    if (d.region) {
      var cluster = continentCentroids[d.region];
      /* if (d.name == "Bermuda") {
        console.log("d:");
        console.log(d);
        console.log("cluster:");
        console.log(cluster);
      } */
      var x = d.x - cluster.x,
          y = d.y - cluster.y,
          l = Math.sqrt(x * x + y * y),
          r = d.radius + cluster.radius;
      if (l != r) {
        l = (l - r) / l * alpha;
        d.x -= x *= l;
        d.y -= y *= l;
        // cluster.x += x;
        // cluster.y += y;
      }
    }
  });
}

function collide(alpha) {	
  var quadtree = d3.quadtree()
		.x((d) => d.x)
    .y((d) => d.y)
    .addAll(centroidItems);
  // return function(d) {
  centroidItems.forEach(function(d) {
    var r = d.radius + maxRadius + Math.max(padding, clusterPadding),
        nx1 = d.x - r,
        nx2 = d.x + r,
        ny1 = d.y - r,
        ny2 = d.y + r;
    quadtree.visit(function(quad, x1, y1, x2, y2) {
      if (quad.data && (quad.data !== d)) {
        var x = d.x - quad.data.x,
            y = d.y - quad.data.y,
            l = Math.sqrt(x * x + y * y),
            r = d.radius + quad.data.radius + (d.cluster === quad.data.cluster ? padding : clusterPadding);
        if (l < r) {
          l = (l - r) / l * alpha;
          d.x -= x *= l;
          d.y -= y *= l;
          quad.data.x += x;
          quad.data.y += y;
        }
      }
      return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
    });
  });
}

</script>
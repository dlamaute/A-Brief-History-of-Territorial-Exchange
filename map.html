<!DOCTYPE html>
<meta charset="utf-8">
<style>

.background {
  fill: none;
  pointer-events: all; 
}

.selectLayer {
  fill: #ccc;
  fill-opacity: 0.5;
  cursor: pointer;
}

.feature {
  fill: #000;
  cursor: pointer;
}

.country {
  fill: #ccc;
  cursor: pointer;
}

.mesh {
  fill: none;
  stroke: #fff;
  stroke-linecap: round;
  stroke-linejoin: round;
}

.centroid {
  stroke: #000;
  stroke-width: 0.1;
  cursor: pointer;
}

.contCentroid {
  stroke: #000;
  stroke-width: 0.1;
  cursor: pointer;
}

.hidden {
  display: none;
}

.tooltip { 
  position: absolute;     
  text-align: center;       
  padding: 2px 5px;       
  font: 12px sans-serif;    
  background: lightgrey; 
  border: 0px;    
  border-radius: 8px;     
  pointer-events: none;     
}

#toggleClusterDiv {
  display: block;
  margin: 50px 0 50px 50px;
}

</style>

<body>
  <div id="toggleClusterDiv">
    <button id="toggle-cluster" type="button">Switch to Comparison View</button>
  </div>
</body>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/topojson.v2.min.js"></script>
<script src="https://d3js.org/d3-queue.v3.min.js"></script>
<script>

var body = d3.select("body");

var width = 960,
    height = 700,
    padding = 1.5,
    clusterPadding = 6,
    maxRadius = height*0.1, // this should actually vary with the current node options
    active = d3.select(null);

var projection = d3.geoMercator()
    .scale(150)
    .translate([width / 2, height / 2]);
  
var zoom = d3.zoom().on("zoom", zoomed);
var path = d3.geoPath().projection(projection);

var countryMode = false;  // delete?

var clustered = false;
var clusterSimulation;
var unclusterSimulation;
var continent_gs;
var continentClusterRadii = {};

// Define the div for the tooltip
let tooltipDiv = body.append("div") 
    .attr("class", "tooltip")       
    .style("opacity", 0);

var svg = body.append("svg")
    .attr("width", width)
    .attr("height", height)
    .on("click", stopped, true);

svg.append("rect")
    .attr("class", "background")
    .attr("width", width)
    .attr("height", height)
    .on("click", reset);

var sankey = body.append("div")
  .attr("class", "sankey")

var base_g = svg.append("g");
var top_g = svg.append("g");

var continentClusterCodes = {
	"Africa": 1,
	"Asia": 2,
	"Europe": 3,
	"North America": 4,
	"South America": 5,
	"Oceania": 6,
	"Antarctica": 7
}

var centroidItems = [];
var continentCentroids = {};
  
svg.call(zoom); // delete this line to disable free zooming

d3.queue()
	.defer(d3.json, "world-continents.json")
	.defer(d3.json, "world-countries.json")
	.defer(d3.csv, "world_country_names.csv")
	.defer(d3.csv, "wrangle.csv")
	.await(main);

function main(error, worldContinents, worldCountries, names, exchange) {
	if (error) throw error;

	var continentsData = topojson.feature(worldContinents, worldContinents.objects.continent).features;
	var countriesData = topojson.feature(worldCountries, worldCountries.objects.countries).features;

	// set up continents
	continent_gs = base_g.append("g")
    .attr("class", "feature continent")
    .selectAll(".feature")
    .data(continentsData)
    .enter()
    .append("path")
    .attr("name", function(d) {return d.properties.continent;})
    .on("click", continentClicked)
    .attr("d", path);

  base_g.append("path")
    .datum(topojson.mesh(worldContinents, worldContinents.objects.continent, function(a, b) { return a !== b; }))
    .attr("class", "mesh")
    .attr("d", path);

  for (var c of continentsData) {
    var centroid = path.centroid(c);
		continentCentroids[c.properties.continent] = {
			  x: path.centroid(c)[0],
			  y: path.centroid(c)[1],
			  radius: 0
		};
	}

  // filter exchange here to get countryExchangeData
  var countryExchangeData = {} // incorporate three-letter code

  // set up countries
  countriesData.filter(function(d) {
  	return names.some(function(n) {
  		if (parseInt(d.id) == parseInt(n.id)) {
  			d.name = n.name;
  			d.nameCode = n.alpha_3;
  			if (n.region != "Americas") {
  				d.region = n.region;
  			} else if (n.subregion == "South America") { 
  				d.region = n.subregion; 
  			} else {
  				d.region = "North America";
  			}
        d.radius = Math.floor(Math.random()*10); // irl to be determined by exchange data
        /* debug for identifying separate clusters */
        switch(continentClusterCodes[d.region]) {
          case 1:
            d.color = "#ffff00";
            break;
          case 2:
            d.color = "#00ffff";
            break;
          case 3:
            d.color = "#00ff00";
            break;
          case 4:
            d.color = "#0000ff";
            break;
          case 5:
            d.color = "#007700";
            break;
          case 6:
            d.color = "#ff00ff";
            break;
          case 7:
            d.color = "#770000";
            break;
          default:
            d.color = "#ccc";
        }
        /* end debug */
  		}
  	});

	  	// for when countryExchangeData is implemented
	  	/* countryExchangeData.some(function(e) {
	  		if (d.nameCode = e.nameCode) {
		  		d.radius = 5;
		  		d.color = #ab1bab;
		  	}
	  	}); */
	});


  var continents = base_g.selectAll(".continent");
  var countries = base_g.selectAll(".country");  // remove

  centroidItems = countriesData.map(function(feature) {
		var centroidItem = {
			x: path.centroid(feature)[0],
			y: path.centroid(feature)[1],
      orig_x: path.centroid(feature)[0],
      orig_y: path.centroid(feature)[1],
			radius: feature.radius,
			name: feature.name,
			color: feature.color,
			cluster: continentClusterCodes[feature.region],
			region: feature.region
		};
		return centroidItem;
  });

  var centroidElements = base_g.selectAll(".centroid")
  	.data(centroidItems)
  	.enter()
  	.append("g");

  var centroids = centroidElements.append("circle")
  	.attr("class", "centroid")
  	.attr("fill", function(d) { return d.color; })
  	.attr("r", function(d) { return d.radius; })
  	.attr("cx", function(d) { return d.x; })
    .attr("cy", function(d) { return d.y; })
    .on("click", countryClicked)
    .on("mouseover", function(d) {
        tooltipDiv.transition()    
            .duration(200)    
            .style("opacity", 1);    
        tooltipDiv.html(d.name)  
            .style("left", (d3.event.pageX) + "px")   
            .style("top", (d3.event.pageY - 28) + "px");  
        })          
    .on("mouseout", function(d) {   
        tooltipDiv.transition()    
            .duration(500)    
            .style("opacity", 0); 
    });

  /* baseSimulation = d3.forceSimulation(centroidItems)
    .velocityDecay(0.1)
    .force("collide", collide)
    .on("tick", clusterTick); */

  clusterSimulation = d3.forceSimulation(centroidItems)
    .velocityDecay(0.1)
    .force('x', d3.forceX()
      .strength(0.007)
      .x(function(d) {
        if(d.region) {
          var cluster = continentCentroids[d.region];
          return cluster.x;
        } else {
          return d.x;
        }
      })
    )
    .force('y', d3.forceY()
      .strength(0.007)
      .y(function(d) {
        if(d.region) {
          var cluster = continentCentroids[d.region];
          return cluster.y;
        } else {
          return d.y;
        }
      })
    )
    .force("collide", collide)
    .stop()
    .on("tick", clusterTick);



  d3.select("#toggle-cluster")
    .on("click", function() {
      return toggleCluster(continent_gs, clustered);
    });

  function startCluster() {
    console.log("cluster called");
    continent_gs.transition()    
            .duration(500)    
            .style("opacity", "0");
    clusterSimulation.restart();
    clustered = true;
  }

  function startUncluster(continent_gs) {
    console.log("uncluster called");
    clusterSimulation.stop();
    
    continent_gs.transition()    
              .duration(500)    
              .style("opacity", "1");

    centroids.transition()
      .duration(0)
      .attr("cx", function(d) { return d.orig_x; })
      .attr("cy", function(d) { return d.orig_y; });

    clustered = false;
  }

  function toggleCluster(continent_gs, clustered) {
    if (!clustered) {
      startCluster();
      d3.select("#toggle-cluster")
        .html("Switch to Geographical View");
    } else {
      startUncluster(continent_gs);
      d3.select("#toggle-cluster")
        .html("Switch to Comparison View");
    }
  }

  function updateBubbles(newData) {
    // TODO: record old locations

    // put in new data
    var newCentroids = base_g.selectAll(".centroid")
      .data(newData);

    // remove unnecessary centroids
    newCentroids.exit().remove();

    // create new centroids
    newCentroids.enter().append("circle")
      .merge(newCentroids) // merge existing and new...?
      .attr("r", function(d) { return d.radius; })
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });

    // TODO: if "clustered", recluster
  }

}

// When a continent is clicked, zoom in
function continentClicked(d) {
  if (active.node() === this) return reset();
  active.classed("active", false);
  active = d3.select(this).classed("active", true);

  if (d.properties.continent != "Asia" && d.properties.continent != "Oceania") {
    var bounds = path.bounds(d),
      dx = bounds[1][0] - bounds[0][0],
      dy = bounds[1][1] - bounds[0][1],
      x = (bounds[0][0] + bounds[1][0]) / 2,
      y = (bounds[0][1] + bounds[1][1]) / 2,
      scale = Math.max(1, Math.min(8, 0.9 / Math.max(dx / width, dy / height))),
      translate = [width / 2 - scale * x, height / 2 - scale * y];
  } else if (d.properties.continent == "Asia") {
    var scale = 2,
      translate = [-1000, 0];
  } else {
    var scale = 2,
      translate = [-1000, -400];
  }

  svg.transition()
      .duration(750)
      .call( zoom.transform, d3.zoomIdentity.translate(translate[0],translate[1]).scale(scale) );

  // base_g.selectAll(".country")

  /* d3.queue()
  	.defer(d3.json, "https://unpkg.com/world-atlas@1/world/50m.json")
  	.defer(d3.csv, "final_data/world_country_names.csv")
  	.await(update);

  function update(error, world, names) {
	  if (error) throw error;

	  var countries = topojson.feature(world, world.objects.countries).features; 

	  var namedCountries = countries.filter(function(d) {
	  	return names.some(function(n) {
	  		if (d.id == n.id) return d.name = n.name;
	  	})
	  });

	  /* base_g.selectAll("path")
	      .data(countries)
	      .enter()
	      .append("path")
	      .attr("d", path)
	      .attr("class", "country")
	      .on("click", countryClicked);

	  base_g.append("path")
	      .datum(topojson.mesh(world, world.objects.countries, function(a, b) { return a !== b; }))
	      .attr("class", "mesh")
	      .attr("d", path);

	  var centroidItems = countries.map(function(feature) {
    		var centroidItem = path.centroid(feature);
    		centroidItem.push(feature.name);
    		return centroidItem;
  		});
	  console.log(centroidItems[0]);

	  var centroidElements = base_g.selectAll(".centroid")
	  	.data(centroidItems)
	  	.enter()
	  	.append("g");

	  centroidElements.append("circle")
	  	.attr("class", "centroid")
	  	.attr("r", 5)
	  	.attr("cx", function(d) { return d[0]; })
        .attr("cy", function(d) { return d[1]; })
        .on("click", countryClicked);

      centroidElements.append("text")
      	.text(function(d) { return d[2]; })
      	.attr("x", function(d) { return d[0]; })
        .attr("y", function(d) { return d[1]; })
        .attr("font-size", "10px")
        .attr("text-anchor", "middle");

	  countryMode = true;
	} */
}

function countryClicked(d) {
	console.log("country clicked");
  if (typeof base_g.selectAll(".centroid") !== 'undefined') {
    var centroids = base_g.selectAll(".centroid");
    var theCentroid;
    centroids.each(function(c) {
      var centroid = d3.select(this);
      if (centroid.attr("cx") == d.x && centroid.attr("cy") == d.y) {
        theCentroid = centroid;
        if (typeof theCentroid !== 'undefined') {
          return true;
        }
      }
      /*  {
        console.log(d.name + " clicked");
        centroid
          .attr("stroke", "red")
          .attr("stroke-width", "10");
        console.log(centroid);
      } else {
        console.log(d.name + " other");
        centroid
          .attr("stroke", "blue")
          .attr("stroke-width", "100");
      } */
    });
    if (typeof theCentroid !== 'undefined') {
      theCentroid
            .attr("stroke", "red")
            .attr("stroke-width", "10");
        console.log(theCentroid);
    }
  }
}

function reset() {
  active.classed("active", false);
  active = d3.select(null);

  svg.transition()
      .duration(750)
      .call( zoom.transform, d3.zoomIdentity ); 

  if (countryMode) {
  	countryMode = false;
  	console.log(base_g.selectAll(".country"));
  	console.log(base_g.selectAll("path"));
  }
}

function zoomed() {
  base_g.style("stroke-width", 1.5 / d3.event.transform.k + "px");
  base_g.attr("transform", d3.event.transform); 
}

// If the drag behavior prevents the default click,
// also stop propagation so we don’t click-to-zoom.
function stopped() {
  if (d3.event.defaultPrevented) d3.event.stopPropagation();
}

function clusterTick(e) {
 	base_g.selectAll(".centroid")
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
}

function collide(alpha) {	
  var quadtree = d3.quadtree()
		.x((d) => d.x)
    .y((d) => d.y)
    .addAll(centroidItems);
  max_r = 0;
  max_cont = "";
  centroidItems.forEach(function(d) {
    var r = d.radius + maxRadius + Math.max(padding, clusterPadding),
        nx1 = d.x - r,
        nx2 = d.x + r,
        ny1 = d.y - r,
        ny2 = d.y + r;
    quadtree.visit(function(quad, x1, y1, x2, y2) {
      if (quad.data && (quad.data !== d)) {
        var x = d.x - quad.data.x,
            y = d.y - quad.data.y,
            l = Math.sqrt(x * x + y * y),
            r = d.radius + quad.data.radius + (d.cluster === quad.data.cluster ? padding : clusterPadding);
        if (l < r) {
          l = (l - r) / l * alpha;
          d.x -= x *= l;
          d.y -= y *= l;
          quad.data.x += x;
          quad.data.y += y;
        }
      }
      if (r > max_r) {
        max_r = r;
        max_cont = d.region;
      }
      return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
    });
    // console.log(max_cont + " " + max_r.toString());
    // continentClusterRadii[max_cont] = max_r;
  });
  // console.log(continentClusterRadii);
  //return continentClusterRadii;
}

</script>
<!DOCTYPE html>
<meta charset="utf-8">
<style>

.background {
  fill: none;
  pointer-events: all; 
}

.selectLayer {
  fill: #ccc;
  fill-opacity: 0.5;
  cursor: pointer;
}

.feature {
  fill: #000;
  cursor: pointer;
}

.country {
  fill: #ccc;
  cursor: pointer;
}

.mesh {
  fill: none;
  stroke: #fff;
  stroke-linecap: round;
  stroke-linejoin: round;
}

.centroid {
  stroke: #000;
  stroke-width: 0.1;
  cursor: pointer;
}

.contCentroid {
  stroke: #000;
  stroke-width: 0.1;
  cursor: pointer;
}

.hidden {
  display: none;
}

.tooltip { 
  position: absolute;     
  text-align: center;       
  padding: 2px 5px;       
  font: 12px sans-serif;    
  background: lightsteelblue; 
  border: 0px;    
  border-radius: 8px;     
  pointer-events: none;     
}

.sankey {}

.header{
  display: block;
  /* position: absolute; */
  left: 2%;
  /* width:550px;
  height:0px; */
  text-align: center;
  /* top: 5%; */
  margin-top: 50px;
  /* z-index: 2; */
}

h1 {
  font-size: 50px;
  /* z-index: 2; */
}

#heading{
  /* padding-top: 5%; */
  font-size: 25px;
  display: inline-block;
}

#yrs{
  /* padding-top: 5%; */
  font-size: 25px;
  display: block;
}

#button-row {
  margin-top: 50px;
  margin-bottom: 30px;
  margin-left: 5%;
  display: block;
}

#story-buttons {
  /* position: absolute; */
  /* left: 41%; */
  /* margin-left: 25px; */
  /* top: 25px */
 /*  z-index: 2; */
 display: inline-block;
}

#other-story-buttons {
  /* position: absolute; */
  /* left: 41%; */
  margin-left: 20px;
  /* top: 75px; */
  /* z-index: 2; */
  display: inline-block;
}

#exchanges {
  margin-left: 20px;
}

.clicked {
  background-color: lightgray;
}

.right-buttons {
  /* position: absolute; */
  left: 80%;
  top: 25px;
  display: inline-block;
  /* z-index: 2; */
  text-align: center;
}

#countries {
  /* padding-top: 2%; */
  display: inline-block;
}

#country {
  text-align: center;
  border-radius: 12px;
  width: 250px;
}

#d3-dropdown {
  text-align: center;
  border-radius: 12px;
  width: 150px;
}

#map-div {
  display: block;
  margin-left: 5%;
  margin-right: 5%;
  width: 90%;
}
  
.base-svg {
 display: block;
 font: 16px"Avenir";
 font-family: "sans-serif";
 font-size: "10";
 text-anchor: "middle";
}
  
.area {
  fill: steelblue;
  clip-path: url(#clip);
}

</style>

<body>
<div class="header">
  <h1>A Brief History of Territorial Exchange</h1>
  <div id="yrs"> - </div>
  <div id="heading"> Search by Country: </div>
  <div id="countries"></div>
</div>

<div id="button-row">
  <div id="story-buttons" class="btn-group" role="group" aria-label="people">
      <button type="button" id="button1" class="btn btn-default" onClick="updateData(false);">Land</button>
      <button type="button" id="button2" class="btn btn-default" onClick="updateData(true);">People</button>
  </div>

  <div id="other-story-buttons" class="btn-group" role="group" aria-label="people">
    <button type="button" id="button3" class="btn btn-default" onClick="updateGains(0);">Gains</button>
    <button type="button" id="button4" class="btn btn-default" onClick="updateGains(1);">Losses</button>
    <button type="button" id="button5" class="btn btn-default" onClick="updateGains(2);">Net</button>
  </div>

  <div class="right-buttons" id="exchanges"></div>
</div>

<div id="map-div"></div>

</body>

<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">
<script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha384-A7FZj7v+d/sdmMqp/nOQwliLvUsJfDHW+k9Omg/a/EheAdgtzNs3hpfag6Ed950n" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js" integrity="sha384-DztdAPBWPRXSA/3eYEEUWrWCy7G5KFbe8fFjk5JAIxUYHKkDx6Qin1DkWx51bBrb" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js" integrity="sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn" crossorigin="anonymous"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>
<link rel="stylesheet"  href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/topojson.v2.min.js"></script>
<script src="https://d3js.org/d3-queue.v3.min.js"></script>
<script>

var body = d3.select("body");
var mapDiv = d3.select("#map-div");

var width = 960,
    height = 500,
    padding = 1.5,
    clusterPadding = 6,
    maxRadius = height*0.1, // this should actually vary with the current node options
    active = d3.select(null);

var lower = 1815;
var upper = 2016;
var isPeople = false;
var exchangeType = null;
var gains = 0;

body.attr("width", (width + 100).toString() + "px").attr("height", (height + 50).toString() + "px");

var projection = d3.geoMercator()
    .scale(150)
    .translate([width / 2, height / 2]);
  
var zoom = d3.zoom().on("zoom", zoomed);
var path = d3.geoPath().projection(projection);

var countryMode = false;  // delete?
var simulation;


// Define the div for the tooltip
let tooltipDiv = body.append("div") 
    .attr("class", "tooltip")       
    .style("opacity", 0);

var svg = mapDiv.append("svg")
    .attr("class", "base-svg")
    .attr("width", width)
    .attr("height", height)
    .on("click", stopped, true);

svg.append("rect")
    .attr("class", "background")
    .attr("width", width)
    .attr("height", height)
    .on("click", reset);

var sankey = body.append("div")
  .attr("class", "sankey")

var base_g = svg.append("g");
var top_g = svg.append("g");

var continentClusterCodes = {
	"Africa": 1,
	"Asia": 2,
	"Europe": 3,
	"North America": 4,
	"South America": 5,
	"Oceania": 6,
	"Antarctica": 7
}

var centroidItems = [];
var continentCentroids = {};
  
svg.call(zoom); // delete this line to disable free zooming

d3.queue()
	.defer(d3.json, "world-continents.json")
	.defer(d3.json, "world-countries.json")
	.defer(d3.csv, "world_country_names.csv")
	.defer(d3.csv, "wrangle.csv")
	.await(setup);

function setup(error, worldContinents, worldCountries, names, exchangeData) {
	if (error) throw error;

  var countrySelect = d3.select("#countries")
        .append("div")
        .append("select")
        .attr("class", "custom-select")
        .attr("id", "country");

      countrySelect.selectAll("option")
        .data(d3.map(exchangeData, function(d){return d["gainer"];}).keys().sort())
        .enter()
        .append("option")
        .text(function (d) { return d; });

  var exchangeSelect = d3.select("#exchanges")
        .append("div")
        .append("select")
        .on('change', onExchangeChange)
        .attr("class", "custom-select")
        .attr("id", "country")
  
      exchangeSelect.selectAll("option")
        .data(d3.map(exchangeData, function(d){return d["procedure"];}).keys().sort())
        .enter()
        .append("option")
        .text(function (d) { return d; });

	var continentsData = topojson.feature(worldContinents, worldContinents.objects.continent).features;
	var countriesData = topojson.feature(worldCountries, worldCountries.objects.countries).features;

	// set up continents
	var continent_gs = base_g.append("g")
    .attr("class", "feature continent")
    .selectAll(".feature")
    .data(continentsData)
    .enter()
    .append("path")
    .attr("name", function(d) {return d.properties.continent;})
    .on("click", continentClicked)
    .attr("d", path);

  base_g.append("path")
    .datum(topojson.mesh(worldContinents, worldContinents.objects.continent, function(a, b) { return a !== b; }))
    .attr("class", "mesh")
    .attr("d", path);

  for (var c of continentsData) {
    var centroid = path.centroid(c);
		continentCentroids[c.properties.continent] = {
			  x: path.centroid(c)[0],
			  y: path.centroid(c)[1],
			  radius: 0
		};
	}

  // filter exchange here to get countryExchangeData
  var countryExchangeData = {} // incorporate three-letter code

  // set up countries
  countriesData.filter(function(d) {
  	return names.some(function(n) {
  		if (parseInt(d.id) == parseInt(n.id)) {
  			d.name = n.name;
  			d.nameCode = n.alpha_3;
  			if (n.region != "Americas") {
  				d.region = n.region;
  			} else if (n.subregion == "South America") { 
  				d.region = n.subregion; 
  			} else {
  				d.region = "North America";
  			}
        d.radius = Math.floor(Math.random()*10); // irl to be determined by exchange data
        /* debug for identifying separate clusters */
        switch(continentClusterCodes[d.region]) {
          case 1:
            d.color = "#ffff00";
            break;
          case 2:
            d.color = "#00ffff";
            break;
          case 3:
            d.color = "#00ff00";
            break;
          case 4:
            d.color = "#0000ff";
            break;
          case 5:
            d.color = "#007700";
            break;
          case 6:
            d.color = "#ff00ff";
            break;
          case 7:
            d.color = "#770000";
            break;
          default:
            d.color = "#ccc";
        }
        /* end debug */
  		}
  	});

	  	// for when countryExchangeData is implemented
	  	/* countryExchangeData.some(function(e) {
	  		if (d.nameCode == e.nameCode) {
		  		d.radius = 5;
		  		d.color = #ab1bab;
		  	}
	  	}); */
	});


  var continents = base_g.selectAll(".continent");
  var countries = base_g.selectAll(".country");  // remove

  centroidItems = countriesData.map(function(feature) {
		var centroidItem = {
			x: path.centroid(feature)[0],
			y: path.centroid(feature)[1],
			radius: feature.radius,
			name: feature.name,
			color: feature.color,
			cluster: continentClusterCodes[feature.region],
			region: feature.region
		};
		return centroidItem;
  });

  simulation = d3.forceSimulation(centroidItems)
	  .velocityDecay(0.1)
    .force('x', d3.forceX()
      .strength(0.006)
      .x(function(d) {
        if(d.region) {
          var cluster = continentCentroids[d.region];
          return cluster.x;
        } else {
          return d.x;
        }
      })
    )
    .force('y', d3.forceY()
      .strength(0.006)
      .y(function(d) {
        if(d.region) {
          var cluster = continentCentroids[d.region];
          return cluster.y;
        } else {
          return d.y;
        }
      })
    )
    .force("collide", collide)
    .stop()
    .on("tick", tick);

  var centroidElements = base_g.selectAll(".centroid")
  	.data(centroidItems)
  	.enter()
  	.append("g");

  var centroids = centroidElements.append("circle")
  	.attr("class", "centroid")
  	.attr("fill", function(d) { return d.color; })
  	.attr("r", function(d) { return d.radius; })
  	.attr("cx", function(d) { return d.x; })
    .attr("cy", function(d) { return d.y; })
    .on("click", countryClicked)
    .on("mouseover", function(d) {
        tooltipDiv.transition()    
            .duration(200)    
            .style("opacity", 1);    
        tooltipDiv.html(d.name)  
            .style("left", (d3.event.pageX) + "px")   
            .style("top", (d3.event.pageY - 28) + "px");  
        })          
    .on("mouseout", function(d) {   
        tooltipDiv.transition()    
            .duration(500)    
            .style("opacity", 0); 
    });

  var selectLayer = top_g.append("rect")
    .attr("class", "selectLayer")
    .attr("width", width)
    .attr("height", height)
    .on("click", startSimulation);

  selectLayer.append("text")
    .text("Click to Start")
    .attr("font-size", "128px")
    .attr("color", "black")
    .attr("x", width/2)
    .attr("y", height/2)
    .attr("text-anchor", "middle");
}

function onExchangeChange() {
    var selected = d3.select(this).property("value");
    exchangeType = selected=="All" ? null : selected;
    updateBubble(lower, upper, isPeople, exchangeType, gains);
    updateTimeline(exchangeType);
};

function updateYearsBanner(lower, upper) {
  var select = d3.select("#yrs")
          .text(lower + " - " + upper);
}

updateYearsBanner(lower, upper);

// When a continent is clicked, zoom in and show the country level map
function continentClicked(d) {
  if (active.node() === this) return reset();
  active.classed("active", false);
  active = d3.select(this).classed("active", true);

  console.log(d);
  if (d.properties.continent != "Asia" && d.properties.continent != "Oceania") {
    var bounds = path.bounds(d),
      dx = bounds[1][0] - bounds[0][0],
      dy = bounds[1][1] - bounds[0][1],
      x = (bounds[0][0] + bounds[1][0]) / 2,
      y = (bounds[0][1] + bounds[1][1]) / 2,
      scale = Math.max(1, Math.min(8, 0.9 / Math.max(dx / width, dy / height))),
      translate = [width / 2 - scale * x, height / 2 - scale * y];
  } else if (d.properties.continent == "Asia") {
    var scale = 2,
      translate = [-1000, 0];
  } else {
    var scale = 2,
      translate = [-1000, -400];
  }

  svg.transition()
      .duration(750)
      .call( zoom.transform, d3.zoomIdentity.translate(translate[0],translate[1]).scale(scale) );
}

function countryClicked(d) {
	console.log("country clicked");
	console.log(d);
}

function reset() {
  active.classed("active", false);
  active = d3.select(null);

  svg.transition()
      .duration(750)
      .call( zoom.transform, d3.zoomIdentity ); 

  if (countryMode) {
  	countryMode = false;
  	console.log(base_g.selectAll(".country"));
  	console.log(base_g.selectAll("path"));
  }
}

function zoomed() {
  base_g.style("stroke-width", 1.5 / d3.event.transform.k + "px");
  base_g.attr("transform", d3.event.transform); 
}

// If the drag behavior prevents the default click,
// also stop propagation so we don’t click-to-zoom.
function stopped() {
  if (d3.event.defaultPrevented) d3.event.stopPropagation();
}

function startSimulation() {
  if (typeof simulation !== 'undefined') {
    top_g.selectAll(".selectLayer").remove();
    simulation.restart();
  }
}

function tick(e) {
 	base_g.selectAll(".centroid")
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
}

function collide(alpha) {	
  var quadtree = d3.quadtree()
		.x((d) => d.x)
    .y((d) => d.y)
    .addAll(centroidItems);
  centroidItems.forEach(function(d) {
    var r = d.radius + maxRadius + Math.max(padding, clusterPadding),
        nx1 = d.x - r,
        nx2 = d.x + r,
        ny1 = d.y - r,
        ny2 = d.y + r;
    quadtree.visit(function(quad, x1, y1, x2, y2) {
      if (quad.data && (quad.data !== d)) {
        var x = d.x - quad.data.x,
            y = d.y - quad.data.y,
            l = Math.sqrt(x * x + y * y),
            r = d.radius + quad.data.radius + (d.cluster === quad.data.cluster ? padding : clusterPadding);
        if (l < r) {
          l = (l - r) / l * alpha;
          d.x -= x *= l;
          d.y -= y *= l;
          quad.data.x += x;
          quad.data.y += y;
        }
      }
      return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
    });
  });
}

function updateTimeline(exchangeType) {

  d3.csv("wrangle.csv", 
    function(d) {
      d.exchange = +d["procedure"];
      d.land = +d["area"];
      d.people = +d["pop"];
      d.year = d["year"];
      d.count = d["count"];

      return d;
    }, 
    function(error, data) {
      if (error) throw error;
      
      svg.selectAll(".focus").remove();
      svg.selectAll(".context").remove();
      
      var x = d3.scaleLinear().range([0, width]),
        y2 = d3.scaleLinear().range([height2, 0]);
        
      var yTicks = 6;
      if (exchangeType=="Annexation") {
        yTicks = 3;
      }
      if (exchangeType=="Conquest") {
        yTicks = 4;
      }
      if (exchangeType=="Unification") {
        yTicks = 6;
      }

      var xAxis = d3.axisBottom(x).ticks(20).tickFormat(d3.format(".4")),
        yAxis2 = d3.axisLeft(y2).ticks(yTicks);

      var brush = d3.brushX()
        .extent([[0, 0], [width, height2]])
        .on("brush end", brushed);
        
      var area2 = d3.area()
        .curve(d3.curveStep)
        .x(function(d) { return x(d["year"]/*.year*/); })
        .y0(height2)
        .y1(function(d) { return y2(d["count"]/*.count*/); });
        
      var focus = svg.append("g")
        .attr("class", "focus")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        
      var context = svg.append("g")
        .attr("class", "context")
        .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

      
      data4timeline = []
      for (i=1816; i<=2018; i++) {
        year_string = "" + i;
        data4timeline.push( {"year": year_string, "count": 0, "pop": 0, "area": 0} );
      }
      
      for (i=0; i<data.length; i++) {
        if (exchangeType=="All" || exchangeType==null || data[i]["procedure"]==exchangeType) {
          thisYear = data[i]["year"]
          for (j=1816; j<=2018; j++) {
            if (thisYear == j) {
              data4timeline[j-1816]["count"] += 1;
            }
          }
        }
      }
      
      // Set the timeline line graph domain
      x.domain(d3.extent(data4timeline, function(d) { return d["year"]/*.year*/; }));
      y2.domain([0, d3.max(data4timeline, function(d) { return d["count"]/*.count*/; })]);

      // Draw the y-axis
      focus.append("g")
         .attr("class", "axis axis--y")
         .attr("transform", "translate(0," + (height + 10) + ")")
         .call(yAxis2);
      
      
      // Draw the line graph given the data
      context.append("path")
          .datum(data4timeline)
          .attr("class", "area")
          .attr("d", area2);

      // Draw the x-axis
      context.append("g")
          .attr("class", "axis axis--x")
          .attr("transform", "translate(0," + height2 + ")")
          .call(xAxis);

      // Draw the brush
      context.append("g")
          .attr("class", "brush")
          .call(brush)
          .call(brush.move, x.range());
    
  });

}

/* here we go */
function updateBubble(lower_bound, upper_bound, type, exchange, gains) {
  d3.csv("wrangle.csv", 
          function(d) {
            d.exchange = d["procedure"];
            d.land = +d["area"];
            d.people = +d["pop"];
            d.year = d["year"];
            d.gainer = d["gainer"];
            d.loser = d["loser"];

            return d;
          }, 
          function(error, data) {
            if (error) throw error;

            svg.selectAll(".node").remove();

            var color = d3.scaleOrdinal()
                      .domain(data.map(function(d){ return d.year; }))
                      .range(['#fbb4ae','#b3cde3','#ccebc5','#decbe4','#fed9a6', '#ffe9a8','#b9bfe3','#fddaec','#cccccc']);

              data2 = data.filter(function(d) {
                if (exchange) {
                  return d.year >= lower_bound && d.year <= upper_bound && d.exchange
                  && d.exchange == exchange;
                }
                else {
                  return d.year >= lower_bound && d.year <= upper_bound;
                }
              });
              
              var variable = gains == 0 ? "gainer" : "loser";

              var data3 = [];
              for (i=0; i < data2.length; i++) {
                //console.log(data2[i]);
                var alreadyPresent = false;
                entity2check = data2[i][variable];
                index2save = null;
                for (j=0; j < data3.length; j++) {
                  if (data3[j][variable] == entity2check) {
                    index2save = j;
                    alreadyPresent = true;
                  }
                }
                if (alreadyPresent == true) {
                  data3[index2save]["land"] += data2[i]["land"];
                  data3[index2save]["people"] += data2[i]["people"];
                }
                else {
                  data3.push(data2[i]);
                }
              }
              
              var root = type == true ? d3.hierarchy({children: data3})
                      .sum(function(d) { return d.people; }) :
                      d3.hierarchy({children: data3})
                      .sum(function(d) { return d.land; });

              var node = svg.selectAll(".node")
                      .data(pack(root).leaves())
                      .enter().append("g")
                      .attr("class", "node")
                      .attr("transform", function(d) { return "translate(" + (d.x + 125) + "," + d.y + ")"; });


              node.append("circle")
                  .attr("id", function(d) { return d.id; })
                  .attr("r", function(d) { return d.r; })
                  .style("fill", function(d) { return color(d.data.year); });


              node.append("text")
                  .attr("font-size", function(d) { return 0.25*d.r + "px"; })
                  .text(function(d) {
                    return gains == 0 ? d.data.gainer : d.data.loser;
                  });
          });
}

function updateNetBubble(lower_bound, upper_bound, type, exchange) {
d3.csv("wrangle.csv", 
        function(d) {
          d.exchange = d["procedure"];
          d.land = +d["area"];
          d.people = +d["pop"];
          d.year = d["year"];
          d.gainer = d["gainer"];
          d.loser = d["loser"];

          return d;
        }, 
        function(error, data) {
          if (error) throw error;

          svg.selectAll(".node").remove();

            data2 = data.filter(function(d) {
              if (exchange) {
                return d.year >= lower_bound && d.year <= upper_bound && d.exchange
                && d.exchange == exchange;
              }
              else {
                return d.year >= lower_bound && d.year <= upper_bound;
              }
            });
            
            var data3 = [];
            for (i=0; i < data2.length; i++) {
              //console.log(data2[i]);
              var alreadyPresentGain = false;
              var alreadyPresentLoss = false;
              entity2check = data2[i]["gainer"];
              otherentity2check = data2[i]["loser"];
              index2save = null;
              index2save1 = null;
              for (j=0; j < data3.length; j++) {
                if (data3[j]["entity"] == entity2check) {
                  index2save = j;
                  alreadyPresentGain = true;
                }
                if (data3[j]["entity"] == otherentity2check) {
                  index2save1 = j;
                  alreadyPresentLoss = true;  
                }
              }
              if (alreadyPresentGain == false && alreadyPresentLoss == false) {
                data2[i]["entity"] = data2[i]["gainer"];
                data3.push(data2[i]);
                newdata = {};
                newdata["exchange"] = -1 * data2[i]["exchange"];
                newdata["land"] = -1 * data2[i]["land"];
                newdata["people"] = -1 * data2[i]["people"];
                newdata["entity"] = data2[i]["loser"];
                data3.push(newdata);
              }
              else {
                if (alreadyPresentGain == true ) {
                  data3[index2save]["land"] += data2[i]["land"];
                  data3[index2save]["people"] += data2[i]["people"];
                }
                else {
                  data3[index2save1]["land"] -= data2[i]["land"];
                  data3[index2save1]["people"] -= data2[i]["people"];
                }
              }
            };

            for (i=0; i < data3.length; i++) {
              data3[i]["peopleLoss"] = data3[i]["people"] >= 0 ? "false" : "true";
              data3[i]["landLoss"] = data3[i]["land"] >= 0 ? "false" : "true";
            }
            
            var root = type == true ? d3.hierarchy({children: data3})
                    .sum(function(d) { return Math.abs(d.people); }) :
                    d3.hierarchy({children: data3})
                    .sum(function(d) { return Math.abs(d.land); });

            var node = svg.selectAll(".node")
                    .data(pack(root).leaves())
                    .enter().append("g")
                    .attr("class", "node")
                    .attr("transform", function(d) { return "translate(" + (d.x + 125) + "," + d.y + ")"; });


            node.append("circle")
                .attr("id", function(d) { return d.id; })
                .attr("r", function(d) { return d.r; })
                .style("fill", function(d) { 
                  if (type == true) {
                    return d.data.peopleLoss == "false" ? '#b3cde3' : '#fbb4ae';
                  }
                  else {
                    return d.data.landLoss == "false" ? '#b3cde3' : '#fbb4ae';
                  } });


            node.append("text")
                .attr("font-size", function(d) { return 0.25*d.r + "px"; })
                .text(function(d) {
                  return d.data.entity;
                });
        });
}
/* end */

</script>